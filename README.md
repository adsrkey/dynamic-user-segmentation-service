# dynamic-user-segmentation-service

# Сервис динамического сегментирования пользователей

# Запуск:

#### Через Makefile:

```
make up
```

#### Через docker-compose

```
docker-compose up --build -d
```

#### Выполнить скрипт для создания таблиц
```
cd deploy/scripts/sql/up.sql
```

#### Импортировать postman коллекцию
```
postman/Task.postman_collection.json
```

#### Swagger Документация
```
http://localhost:8080/swagger/index.html
```

# Остановка:
```
make down
```
Или
```
docker-compose down
```

# Запросы:
### [POST] Добавление в сегмент
```
curl --location 'http://localhost:8080/api/v1/segments' \
--header 'Content-Type: application/json' \
--data '{
    "slug": "AVITO_VOICE_MESSAGES",
    "percent": 10
}'
```

"slug" - название сегмента,

"percent" - процент пользователей которые будут попадать в сегмент автоматически (опционально)

---

### [DELETE] Удаление из сегмента
```
curl --location --request DELETE 'http://localhost:8080/api/v1/segments' \
--header 'Content-Type: application/json' \
--data '{
    "slug": "AVITO_VOICE_MESSAGES"
}'
```

"slug" - название сегмента


---

### [POST] Добавление пользователя в сегмент
```
curl --location 'http://localhost:8080/api/v1/users/segments' \
--header 'Content-Type: application/json' \
--data '{
    "user_id":"11111111-2222-5678-1234-567812345678",
    "slugs_add":["AVITO_VOICE_MESSAGES"],
    "slugs_del":["AVITO_PROPOSAL"],
    "ttl":"2023-08-30T21:15:00.000Z"
}'
```

"user_id" - id пользователя в формате UUID,

"slugs_add" - список названий сегментов для добавления,

"slugs_del" - список названий сегментов для удаления,

"ttl" (optional) - время автоматического удаления пользователя из сегмента

---
### [GET] Получение активных сегментов
```
curl --location --request GET 'http://localhost:8080/api/v1/users/segments' \
--header 'Content-Type: application/json' \
--data '{
    "user_id": "11111111-1234-5678-1234-567812345678"
}'
```

"user_id" - id пользователя в формате UUID

---
### [GET] Проверка, что сервис работает
```
curl --location 'http://localhost:8080/health'
```
---
### [POST] Получение ссылки с отчетом по пользователю за определённое время
```
curl --location 'http://localhost:8080/api/v1/users/segments/reports' \
--header 'Content-Type: application/json' \
--data '{
    "user_id":"12345678-1234-5678-1234-567812345678",
    "year":2023,
    "month":8
}'
``` 

"user_id" - id пользователя в формате UUID,

"year" - год,

"month" - месяц 

---
### [GET] Получение отчета в формате csv
```
curl --location 'http://localhost:8080/api/v1/users/segments/files?file_id=e6f54f2a-afc5-4079-9910-7f56c6a720d6' \
--data ''
```

"file_id" - id файла отчёта в формате csv

---

# Q&A:
- (?) Вопрос: Метод создания пользователя не описан в ТЗ:
- Решение: ID пользователя добавляется в базу данных при первом запросе добавления/удаления пользователя в сегмент
---
- (?) Вопрос:  Отменять ли добавление slug_add сегментов пользователю, если удалить slug_del в запросе по каким-то причинам не получилось и наоборот
- Решение: Если что-то не прошло удачно, то изменения не применяются, то есть кейс не удачен
---
- (?) Вопрос: Что делать, если slug (названия) сегментов будут повторятся при добавлении или удалении?
- Решение:  В таком случае проверять этот кейс на этапе валидации запроса и отправлять ошибку
---
- (?) Вопрос: GET запрос тоже должен включать json?
- Решение: В ТЗ описано, что все эндпоинты должны принимать и возвращать формат JSON. По спецификации GET запрос не должен иметь тела, но такие случаи допускаются. Принимаю решение в пользу формата и добавлю middleware с проверкой Content-Type заголовка, чтобы он включал application/json при любых запросах к серверу.
---
- (?) Вопрос: Какой TTL формат лучше использовать в запросе? 
- Решение: Есть возможность указать в любом формате и распарсить в определённую дату. Необходимо знать минимальное время нахождения в сегменте. Я выбрал формат **RFC 3339**, дата включает в себя конкретное время вплоть до наносекунд (в принципе, всё, что после минут можно отбросить и заполнить нулями).
---
- (?) Вопрос: Каким образом понимать кого автоматически добавлять в сегмент? И нужен ли пересчёт количества пользователей, если в базе данных появились новые?
- Решение: Допустим процент пользователей считается в момент создания сегмента и не будет пересчитываться после. Добавять будем пользователей случайным образом, реализуя алгоритм случайного перемешивания.
